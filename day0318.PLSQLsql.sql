-- PL/SQL
-- DECLARE [실행에 필요한 여러 요소 선언]선택;
-- BEGIN [작업을 위해 실제 실행하는 명령어]필수;
-- EXCEPTION [PL/SQL 수행 도중 발생하는 오류 처리]선택;
-- END;

SET SERVEROUTPUT ON; -- CTRL + SHIFT + O
BEGIN 
    DBMS_OUTPUT.PUT_LINE('HELLO, PL/SQL');
END;
/

-- 변수 : 데이터를 일시적으로 저장, 저장되는 값 변경 가능. 
-- 변수 이름 자료형 := 값 또는 값이 도출되는 여러 표현식;
DECLARE
    V_EMPNO NUMBER(4) := 7788;
    V_ENAME VARCHAR2(10);
BEGIN
    V_ENAME := 'SCOTT';
    DBMS_OUTPUT.PUT_LINE('V_EMPNO : ' || V_EMPNO);
    DBMS_OUTPUT.PUT_LINE('V_ENAME : ' || V_ENAME);
END;
/

-- 상수 : 한 번 저장한 값이 프로그램 종료시까지 유지
-- 변수 이름 CONSTANT 자료형 := 값 또는 값을 도출하는 여러 표현식;

DECLARE
    V_TAX CONSTANT NUMBER(1) := 3;
BEGIN
    DBMS_OUTPUT.PUT_LINE('V_TAX : ' || V_TAX);
END;
/

-- 변수의 기본값 지정
-- 변수 이름 자료형 DEFAULT 값 또는 값 도출되는 여러 표현식;

-- 변수에 NULL값 저장 막기
-- 변수 이름 자료형 NOT NULL := DEFAULT 값 또는 값이 도출되는 여러 표현식;

DECLARE
    V_DEPTNO NUMBER(2) NOT NULL DEFAULT 10;
BEGIN
    DBMS_OUTPUT.PUT_LINE('V_DEPTNO : ' || V_DEPTNO);
    V_DEPTNO := 20;
    DBMS_OUTPUT.PUT_LINE('V_DEPTNO : ' || V_DEPTNO);
END;
/

-- 변수의 자료형
-- 1) 스칼라형 : 내부 구성 요소가 없는 단일 값(NUMBER 등등 동일하나, BOOLEAN은 PL/SQL에서만 가능-T/F/NULL)
-- 2) 참조형 : 특정 테이블의 열, 행 구조를 참조(%TYPE-열참조, %ROWTYPE-행참조)
-- 변수 이름 테이블 이름.열이름%TYPE; / 변수 이름 테이블 이름%ROWTYPE;
DECLARE
    V_DEPTNO DEPT.DEPTNO%TYPE := 50;
BEGIN
    DBMS_OUTPUT.PUT_LINE('V_DEPTNO : ' || V_DEPTNO);
END;
/


DECLARE
    V_DEPT_40 DEPT%ROWTYPE;
BEGIN
    SELECT * INTO V_DEPT_40 FROM DEPT WHERE DEPTNO=40;
    DBMS_OUTPUT.PUT_LINE('DEPTNO : ' || V_DEPT_40.DEPTNO);
    DBMS_OUTPUT.PUT_LINE('DNAME : ' || V_DEPT_40.DNAME);
    DBMS_OUTPUT.PUT_LINE('LOC : ' || V_DEPT_40.LOC);
END;
/
-- 3) 복합형 : 컬렉션(TABLE), 레코드(RECORD)
-- 4) LOB형 : LARGE OBJECT

-- IF-THEN-ELSE OR ELSIF 끝날 때 END IF;
DECLARE
    V_NUMBER NUMBER := 10;
BEGIN
    IF mod(V_NUMBER, 2) = 1 
    THEN
        DBMS_OUTPUT.PUT_LINE('V_NUMBER' || '는 홀수입니다.');
    ELSE
        DBMS_OUTPUT.PUT_LINE('V_NUMBER' || '는 짝수입니다.');
    END IF;
END;
/

DECLARE
    V_SCORE NUMBER := 87;
BEGIN
    IF V_SCORE >= 90 THEN
        DBMS_OUTPUT.PUT_LINE('A학점');
    ELSIF V_SCORE >= 80 THEN
        DBMS_OUTPUT.PUT_LINE('B학점');
    ELSE DBMS_OUTPUT.PUT_LINE('C학점');
    END IF;
END;
/
-- CASE 조건문(생략함)
-- 반복문 : 기본LOOP, WHILE LOOP, FOR LOOP, Cursor FOR LOOP
-- 반복 수행 제어 : EXIT, EXIT-WHEN, CONTINUE, CONTINUE-WHEN
DECLARE
    V_NUM NUMBER := 0;
BEGIN
    LOOP
        DBMS_OUTPUT.PUT_LINE(V_NUM);
        V_NUM := V_NUM +1;
        EXIT WHEN V_NUM > 4;
    END LOOP;
END;
/

DECLARE
    V_NUM NUMBER := 0;
BEGIN
    WHILE V_NUM < 5 LOOP
        DBMS_OUTPUT.PUT_LINE(V_NUM);
        V_NUM := V_NUM+1;
    END LOOP;
END;
/

DECLARE
    V_STAR VARCHAR2(10) := '*';
    V_NUM NUMBER := 0;
BEGIN
    WHILE V_NUM < 5 LOOP
        DBMS_OUTPUT.PUT_LINE(V_STAR);
        V_STAR := V_STAR||'*';
        V_NUM := V_NUM+1;
    END LOOP;
END;
/

BEGIN
    FOR i IN 0..4 LOOP
        DBMS_OUTPUT.PUT_LINE(i);
    END LOOP;
END;
/

BEGIN
    FOR i IN REVERSE 0..4 LOOP
        DBMS_OUTPUT.PUT_LINE(i);
    END LOOP;
END;
/

BEGIN
    FOR i IN REVERSE 0..4 LOOP
        CONTINUE WHEN MOD(i,2) = 1;
        DBMS_OUTPUT.PUT_LINE(i);
    END LOOP;
END;
/

-- 레코드 : 자료형이 다른 데이터들을 하나의 변수에 저장
-- TYPE 레코드 이름 IS RECORD(변수 이름 자료형 NOT NULL := (또는 DEFAULT)값 또는 값이 도출되는 여러 표현식)

DECLARE
    TYPE REC_DEPT IS RECORD(
        DEPTNO NUMBER(2) NOT NULL := 10,
        DNAME DEPT.DNAME%TYPE,
        LOC DEPT.LOC%TYPE   
    );
    DEPT_REC REC_DEPT;
BEGIN
    DEPT_REC.DEPTNO := 99;
    DEPT_REC.DNAME := 'DATABASE';
    DEPT_REC.LOC := 'SEOUL';
    DBMS_OUTPUT.PUT_LINE(DEPT_REC.DEPTNO);
    DBMS_OUTPUT.PUT_LINE(DEPT_REC.DNAME);
    DBMS_OUTPUT.PUT_LINE(DEPT_REC.LOC);
END;
/

CREATE TABLE DEPT_RECORD AS SELECT * FROM DEPT;
SELECT * FROM DEPT_RECORD;

DECLARE
    TYPE REC_DEPT IS RECORD(
        DEPTNO NUMBER(2) NOT NULL := 10,
        DNAME DEPT.DNAME%TYPE,
        LOC DEPT.LOC%TYPE   
    );
    DEPT_REC REC_DEPT;
BEGIN
    DEPT_REC.DEPTNO := 99;
    DEPT_REC.DNAME := 'DATABASE';
    DEPT_REC.LOC := 'SEOUL';
    INSERT INTO DEPT_RECORD VALUES DEPT_REC;
END;
/

DECLARE
    TYPE REC_DEPT IS RECORD(
        DEPTNO NUMBER(2) NOT NULL := 10,
        DNAME DEPT.DNAME%TYPE,
        LOC DEPT.LOC%TYPE   
    );
    DEPT_REC REC_DEPT;
BEGIN
    DEPT_REC.DEPTNO := 55;
    DEPT_REC.DNAME := 'DB';
    DEPT_REC.LOC := 'SEOUL';
    UPDATE DEPT_RECORD SET ROW = DEPT_REC WHERE DEPTNO=99;
END;
/

DECLARE
    TYPE REC_DEPT IS RECORD (
        DEPTNO DEPT.DEPTNO%TYPE,
        DNAME DEPT.DNAME%TYPE,
        LOC DEPT.LOC%TYPE
    );
    TYPE REC_EMP IS RECORD(
        EMPNO EMP.EMPNO%TYPE,
        ENAME EMP.ENAME%TYPE,
        DINFO REC_DEPT
    );
    EMP_REC REC_EMP;
BEGIN
    SELECT EMPNO, ENAME, D.DEPTNO, DNAME, LOC
    INTO EMP_REC.EMPNO, EMP_REC.ENAME, 
    EMP_REC.DINFO.DEPTNO, EMP_REC.DINFO.DNAME, EMP_REC.DINFO.LOC
    FROM EMP E, DEPT D WHERE E.DEPTNO = D.DEPTNO AND EMPNO = 7788;
    
    DBMS_OUTPUT.PUT_LINE(EMP_REC.EMPNO);
    DBMS_OUTPUT.PUT_LINE(EMP_REC.ENAME);
    DBMS_OUTPUT.PUT_LINE(EMP_REC.DINFO.DEPTNO);
    DBMS_OUTPUT.PUT_LINE(EMP_REC.DINFO.DNAME);
    DBMS_OUTPUT.PUT_LINE(EMP_REC.DINFO.LOC);
END;
/

-- COLLECTION : 특정 자료형의 데이터를 여러 개 저장하는 복합 자료형
-- 연관배열(ASSOCIATTIVE ARRAY (OR INDEX BY TABLE))
-- TYPE 연관 배열 이름 IS TABLE OF 자료형[NOT NULL] INDEX BY 인덱스형;
DECLARE
    TYPE ITAB_EX IS TABLE OF VARCHAR2(20)
    INDEX BY PLS_INTEGER;
    
    TEXT_ARR ITAB_EX;
BEGIN
    TEXT_ARR(1) := '1ST DATA';
    TEXT_ARR(2) := '2ND DATA';
    TEXT_ARR(3) := '3RD DATA';
    TEXT_ARR(4) := '4TH DATA';
    FOR i IN 1..4 LOOP
        DBMS_OUTPUT.PUT_LINE(TEXT_ARR(i));
    END LOOP;
END;
/

DECLARE
    TYPE REC_DEPT IS RECORD(
        DEPTNO DEPT.DEPTNO%TYPE,
        DNAME DEPT.DNAME%TYPE
    );
    TYPE ITAB_DEPT IS TABLE OF REC_DEPT
    INDEX BY PLS_INTEGER;
    
    DEPT_ARR ITAB_DEPT;
    IDX PLS_INTEGER :=0;
BEGIN
    FOR i IN (SELECT DEPTNO, DNAME FROM DEPT) LOOP
        IDX := IDX +1;
        DEPT_ARR(IDX).DEPTNO := i.DEPTNO;
        DEPT_ARR(IDX).DNAME := i.DNAME;
    END LOOP;
    
    FOR r IN 1..IDX LOOP
        DBMS_OUTPUT.PUT_LINE(DEPT_ARR(r).DEPTNO||' : '|| DEPT_ARR(r).DNAME);
    END LOOP;
END;
/

-- 컬렉션 메서드 : EXISTS(n), COUNT, LIMIT, FIRST, LAST, PRIOR(n), NEXT(n), DELETE, EXTEND, TRIM
-- 중첩 테이블 (NESTED TABLE)
-- VARRAY(VARIABLE-SIZE ARRAY)
